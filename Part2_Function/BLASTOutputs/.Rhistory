xMax <- max(na.omit(Ngens) )  #We need to figure out the largest number of generations needed to reach popMax, and build the plot around that value.
plot (x=1:xMax, y=log(seq(1, 12000, by=12000/xMax)) , #These are the 'fake' x vs y plotting coordinates that give the appropriate axes.  I picked 12000 because the value of popmax was 10000, so that should accommodate things nicely, but this is a somewhat arbitrary decision.
type = "n", bty="n", ylim = c(0,10), xlim=c(0,xMax + 5 ), #Various graphing params
xlab = "N generations of Musk Ox", ylab="Log(Musk Ox Population Size)",  #Labels
main="Population size over time for 1000 simulations")
for(i in popList) {
lines(i)
col = rgb(0, 1, 0, alpha = 0.5)
}
hist(x=Ngens, col = "blue",
xlab = "N generations to >10k Musk Ox", ylab = "Frequency",
main = "Distribution of Simulated Genmax", breaks = (seq.int(0,1000, by = 2)),
xlim = c(0,30), ylim = c(0, 300))
xMax <- max(na.omit(Ngens) )  #We need to figure out the largest number of generations needed to reach popMax, and build the plot around that value.
plot (x=1:xMax, y=log(seq(1, 12000, by=12000/xMax)) , #These are the 'fake' x vs y plotting coordinates that give the appropriate axes.  I picked 12000 because the value of popmax was 10000, so that should accommodate things nicely, but this is a somewhat arbitrary decision.
type = "n", bty="n", ylim = c(0,10), xlim=c(0,xMax + 5 ), #Various graphing params
xlab = "N generations of Musk Ox", ylab="Log(Musk Ox Population Size)",  #Labels
main="Population size over time for 1000 simulations")
for(i in popList) {
lines(i)
col = rgb(red = 0, blue = 1, green = 0, alpha = 0.5)
}
? rgb
xMax <- max(na.omit(Ngens) )  #We need to figure out the largest number of generations needed to reach popMax, and build the plot around that value.
plot (x=1:xMax, y=log(seq(1, 12000, by=12000/xMax)) , #These are the 'fake' x vs y plotting coordinates that give the appropriate axes.  I picked 12000 because the value of popmax was 10000, so that should accommodate things nicely, but this is a somewhat arbitrary decision.
type = "n", bty="n", ylim = c(0,10), xlim=c(0,xMax + 5 ), #Various graphing params
xlab = "N generations of Musk Ox", ylab="Log(Musk Ox Population Size)",  #Labels
main="Population size over time for 1000 simulations")
for(i in popList) {
lines(i)
col = rgb(red = 0, blue = 1, green = 0, alpha = 0.5)
}
#Exercise 4 - Stochastic Population Growth
initsize <- 4 #Initial population size
initsize
#Having trouble printing out results
KFC <- function(temp, input, out) {
units <- c("K", "F", "C")
if ( ! any( input == units ) ) { stop ("input must be one of: K, F, C") }
if ( ! any( out == units ) )   { stop ("out must be one of: K, F, C") }
if (any(input == out)) {
stop("Error: input and out units are identical")
}
if (input == "C") {
if (out == "K") {
return(CtoK(temp))
}
if (out == "F") {
return(CtoF(temp))
}
}
if (input == "F") {
if (out == "C") {
return(FtoC(temp))
}
if (out == "K") {
intC <- FtoC(temp)
return(CtoK(intC))
}
}
if (input == "K") {
if (out == "C") {
return(KtoC(temp))
}
if (out == "F") {
Kcel <- KtoC(temp)
rreturn(CtoF(Kcel))
}
}
}
KFC( temp = 32:45, input = "F", out = "C")
KFC( temp = 32:45, input = "C", out = "F")
KFC( temp = 32:45, input = "K", out = "F")
#Exercise 3 - Temperature Functions
CtoF <- function(Centigrade) {
out <- (((9/5) * Centigrade) + 32)
return(out)
}
FtoC <- function(Fahrenheit) {
out <- ((5/9) * (Fahrenheit - 32))
return(out)
}
FtoC(25:35)
CtoK <- function(Centigrade) {
out <- (Centigrade + 273.15)
return(out)
}
CtoK(-200:-215)
KtoC <- function(Kelvin) {
out <- (Kelvin - 273.15)
}
#Having trouble printing out results
KFC <- function(temp, input, out) {
units <- c("K", "F", "C")
if ( ! any( input == units ) ) { stop ("input must be one of: K, F, C") }
if ( ! any( out == units ) )   { stop ("out must be one of: K, F, C") }
if (any(input == out)) {
stop("Error: input and out units are identical")
}
if (input == "C") {
if (out == "K") {
return(CtoK(temp))
}
if (out == "F") {
return(CtoF(temp))
}
}
if (input == "F") {
if (out == "C") {
return(FtoC(temp))
}
if (out == "K") {
intC <- FtoC(temp)
return(CtoK(intC))
}
}
if (input == "K") {
if (out == "C") {
return(KtoC(temp))
}
if (out == "F") {
Kcel <- KtoC(temp)
rreturn(CtoF(Kcel))
}
}
}
KFC( temp = 32:45, input = "F", out = "C")
KFC( temp = 32:45, input = "C", out = "F")
KFC( temp = 32:45, input = "K", out = "F")
KFC( temp = 100:115, input = "k", out = "C")  #Oops, typo!
##Error: input must be one of: K, F, C
KFC( temp = 100:115, input = "K", out = "K")  #Oops, typo!
#Exercise 4 - Stochastic Population Growth
initsize <- 4 #Initial population size
initsize
initsize <- 10 #Initial population size
rateMean <- 0.7
rateSD <- 0.5
maxPop <- 10000
Nsims <- 1000
Ngens <- 1:length(Nsims)
popList <- list(x = 1:length(Nsims))
for (i in 1:Nsims) {
gen <- 1
popSizeNow <- initsize
popSizeVec <- popSizeNow
while (popSizeNow < maxPop) {
growthRate <- rnorm(n = 1, mean = rateMean, sd = rateSD)
popSizeNow <- round(popSizeNow + (popSizeNow * growthRate))
if (popSizeNow >= 2) {
gen <- gen + 1
popSizeVec[gen] <- popSizeNow
} else {
popSizeVec[gen+1] <- 0
gen <- NA
break
}
}
Ngens[i] <- gen
popList[[i]] <- popSizeVec
}
Ngens
popList
#Probability of population extinction
probExtinct <- sum(is.na(Ngens)) / Nsims
cat(c("The probability of extinction is", probExtinct))
for(i in 1:Nsims) {
par(mfrow = c(1,2))
hist(x=Ngens, col = "blue",
xlab = "N generations to >10k Musk Ox", ylab = "Frequency",
main = expression(paste("Distribution of Simulated Gen"["max"])), breaks = (seq(0,30,2)),
xlim = c(0,30), ylim = c(0, 300))
xMax <- max(na.omit(Ngens) )  #We need to figure out the largest number of generations needed to reach popMax, and build the plot around that value.
plot (x=1:xMax, y=log(seq(1, 12000, by=12000/xMax)) , #These are the 'fake' x vs y plotting coordinates that give the appropriate axes.  I picked 12000 because the value of popmax was 10000, so that should accommodate things nicely, but this is a somewhat arbitrary decision.
type = "n", bty="n", ylim = c(0,10), xlim=c(0,xMax + 5 ), #Various graphing params
xlab = "N generations of Musk Ox", ylab="Log(Musk Ox Population Size)",  #Labels
main="Population size over time for 1000 simulations")
for(i in 1:Nsims) {
lines(x = 1:length(popList[[i]]), y = log(popList[[i]]),
col = rgb(red = 0, blue = 1, green = 0, alpha = 0.5))
}
dev.off()
#Comparing Theoretical vs Observed Distributions
obs <- rnorm(1000, mean = 40, sd = 4 )
head(obs)
hist(obs, prob = T, col = "light blue")
#Generate a string of relevant values over which to calculate the exact theoretical probability density values
X <- seq(from = 20, to = 60, by = 0.5)
Y = dnorm(X, mean = 40, sd = 4)
head(Y)
tail(Y)
#Can overlay the simulated "observations" and the calculated density values
hist(x = obs, prob = T, col = "light blue")
lines(x = X, y = Y, lwd = 3)
## ---- fig.height = 5, fig.width= 7, fig.align="center"-------------------
hist(x = trees$Volume, col="green", prob=T)
#pRactice: Theoretical Trees
hist(x = trees$Volume, col="green", prob=T)
#Use dexp() to generate probability density values over integers 1-100
hist(trees$Volume, col="green", prob=T)
volMean <- mean(trees$Volume)
lines(x = 1:100, y = dexp(1:100, 1/volMean), lwd = 3)
#Random Numbers
set.seed(1)
rnorm(10)
set.seed(1)
rnorm(10)
set.seed(1)
rnorm(10)
#Without set.seed() you get different values each time
set.seed(1)
rnorm(10)
#set.seed(1)
rnorm(10)
#set.seed(1)
rnorm(10)
#Randomizing Existing Data
X <- 1:10
sample(X)
sample(X)
sample(X)
#Correlation between height and girth
cor(trees$H, trees$G)
plot(trees$Height ~ trees$Girth, cex=2, col="blue", pch=19)
#Statistically significant?
cor(trees$Height, sample(trees$Girth) )
cor(trees$Height, sample(trees$Girth) )
cor(trees$Height, sample(trees$Girth) )
#Create your own null distribution
nullExtreme <- sum( treeCor >= obsCor)
print(nullExtreme)
nullExtreme / length(treeCor)
set.seed(1)
Nperms <- 10000
treeCor <- numeric(length=Nperms)
for (i in seq_len(Nperms)) {
nullCor <- cor ( trees$Height, sample(trees$Girth))
treeCor[i] <- nullCor
}
hist(treeCor, col = "grey", xlab = "Null correlation values", main = "")
obsCor <- cor(trees$Height, trees$Girth)
abline(v = obsCor, col = "red", lwd = 3)
nullExtreme <- sum( treeCor >= obsCor)
print(nullExtreme)
nullExtreme / length(treeCor)
#Null Distributions and Statistics
set.seed(2)
TS <- 22  #Our observations. Also a test statistic.
Nsims <- 100000
nullVec <- numeric(length=Nsims)
for (i in 1:Nsims) {
nullVec[i] <- rbinom(n=1, size=30, prob=.5 )
}
pval <- sum( nullVec >= 22 )/Nsims
pval
## ------------------------------------------------------------------------
set.seed(2)
TS <- 22  #Our observations.  Also a test statistic
Nsims <- 100000
nullVec <-  rbinom(n=Nsims, size=30, prob=.5 )
pval <- sum( nullVec >= 22 )/Nsims
pval
#binom.test()
args(binom.test)
binom.test(x = 22, n = 30, alt = "greater")
#Return to tree example
cor(trees$Height, trees$Girth)
plot(trees$Height ~ trees$Girth, cex=2, col="blue", pch=19)
#Generate null - use random permutations
set.seed(1)
Nperms <- 10000 # now using 10k permutations!
treeCor <- numeric(length=Nperms)
for (i in seq_len(Nperms) ) {
nullCor <- cor( trees$Height, sample(trees$Girth) )
treeCor[i] <- nullCor
}
hist(treeCor, col="grey", xlab = "Null correlation values", main = "")
obsCor <- cor( trees$Height, trees$Girth )
abline(v = obsCor, col="red", lwd=3)
## ------------------------------------------------------------------------
nullExtreme <- sum( treeCor >= obsCor)
print(nullExtreme)
nullExtreme / length(treeCor)
## ------------------------------------------------------------------------
pval2tail <- ( sum(treeCor >= obsCor | treeCor <= -obsCor)/Nperms )
#How to generate a two-tailed p-value
pval2tail <- ( sum(treeCor >= obsCor | treeCor <= -obsCor)/Nperms )
pval2tail
#Another way to do the same thing...
mean(abs(treeCor) >= obsCor)
#Floating point numbers
x <- 0.3
y <- 0.3
x == y
x <- 0.3
y <- .1+.2
x == y
#Can force R to display the true value rather than the print value
x <- 0.3
y <- .1+.2
print(x)
print(y)
print(x, digits = 22)
print(y, digits = 22)
y-x
#Another example
x <- 0.00000000000000000000000001
y <- 0.000000000000000000000000000000001
x == y
(x + 1) == (y + 1)
(5 * x) == (5 * y)
#pRactice
for (i in 1:1000) {
isNumberBad <- !is.finite(10^i)
if (isNumberBad) {
cat("Number is bad:", i, "\t10^i value:", 10^i, "\tPrev. value:", 10^(i-1), "\n")
break
}
}
#pRactice
for (i in seq(1, 10^10, 1000)) {
isNumberBad <- !is.finite(as.integer(i))
if (isNumberBad) {
cat("Number is bad:", i, "\tvalue:", i, "\tPrev. value:", i-1, "\n")
break
}
}
#The largest integer?
for (i in 1:1000) {
isNumberBad <- !is.finite(10^i)
if (isNumberBad) {
cat("Number is bad:", i, "\t10^i value:", 10^i, "\tPrev. value:", 10^(i-1), "\n")
break
}
}
#The largest integer?
for (i in 1:1000) {
isNumberBad <- !is.finite(10^i)
if (isNumberBad) {
cat("Number is bad:", i, "\t10^i value:", 10^i, "\tPrev. value:", 10^(i-1), "\n")
break
}
}
print(i)
#pRactice
for (i in seq(1, 10^10, 1000)) {
isNumberBad <- !is.finite(as.integer(i))
if (isNumberBad) {
cat("Number is bad:", i, "\tvalue:", i, "\tPrev. value:", i-1, "\n")
break
}
}
#The largest integer?
for (i in 1:1000) {
isNumberBad <- !is.finite(10^i)
if (isNumberBad) {
cat("Number is bad:", i, "\t10^i value:", 10^i, "\tPrev. value:", 10^(i-1), "\n")
break
}
}
#pRactice
for (i in seq(1, 10^10, 1000)) {
isNumberBad <- !is.finite(as.integer(i))
if (isNumberBad) {
cat("Number is bad:", i, "\tvalue:", i, "\tPrev. value:", i-1, "\n")
break
}
}
print(i)
#pRactice
for (i in 1:1000) {
isNumberBad <- !is.finite(10^i)
if (isNumberBad) {
cat("Number is bad:", i, "\t10^i value:", 10^i, "\tPrev. value:", 10^(i-1), "\n")
break
}
}
#p-values
means <- seq(0,50,5)
for (i in means){
out <- t.test( x=rnorm(200, mean=i), mu=0 )
print(out$p.value)
}
#How to know your limits
.Machine #Gives values for min and max numerical representation
#2.2e-16
set.seed(2)
out <- t.test( x=rnorm(200, mean=30), mu=0 )
print(out)
out$p.value
#
print( .Machine$double.eps )
#
include_graphics("./e_to_the_pi_minus_pi.png")
tmpchar
#EXTRA: Clean the sequences (remove ".")
tmpchar <- as.character(pierisGenome)
##Upload pierisGenome dataset
pierisGenome <- readAAStringSet(file = "Pieris_rapae_proteins.fa")
? plot
ls
ls()
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("GOstats")
library("AnnotationForge")
#Available Organisms
library("AnnotationForge")
available.dbschemas()
#Available Organisms
library("AnnotationForge")
install.packages("BiocManager")
install.packages("BiocManager")
BiocManager::install("GOstats")
Yes
BiocManager::install("GOstats")
#Available Organisms
library("AnnotationForge")
available.dbschemas()
library("org.Hs.eg.db")
browseVignettes("GOstats")
#Available Organisms
library("AnnotationForge")
#Available Organisms
library("cachem")
#Available Organisms
library("AnnotationDbi")
#Install GOstats
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("GOstats")
#Available Organisms
library("AnnotationForge")
available.dbschemas()
#Install GOstats
if (!requireNamespace("BiocManager", quietly = TRUE))
BiocManager::install("GOstats")
#Available Organisms
library("AnnotationForge")
library(BiocManager)
#Install GOstats
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("GOstats")
library(GOstats)
library(AnnotationDbi)
library(cachem)
library(AnnotationForge)
BiocManager::install("GOstats")
#Available Organisms
library("AnnotationForge")
available.dbschemas()
#Install GOstats
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("GOstats")
library(DBI)
library(GOstats)
library(AnnotationDbi)
library(AnnotationForge)
#Install GOstats
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("GOstats")
#Available Organisms
library("AnnotationForge")
available.dbschemas()
#Available Organisms
library("AnnotationForge")
available.dbschemas()
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("GOstats")
#Available Organisms
library("AnnotationForge")
available.dbschemas()
library(GOstats)
# Set directory for output files
outdir <- "../../Output/A-E_GO_results/"
path.in <- "../../Input_files/A-E_ProteinLists/"
files.in <- list.files(path = path.in, pattern = "ids.csv")
# read files of subset-specific proteins into a list for each subset
manduca.list <- lapply(paste0(path.in, files.in[1:3]), scan, what = "character", skip = 1)
#Install GOstats
if (!requireNamespace("BiocManager", quietly = TRUE))
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("GOstats")
#Available Organisms
library("AnnotationForge")
library(AnnotationDbi)
available.dbschemas()
library(BiocManager)
library(GOstats)
library("GSEABase")
library("GSEABase")
install.packages("vctrs", repos = "https://packagemanager.rstudio.com/cran/latest")
library(GOstats)
library(GOstats)
BiocManager::install("GOstats")
library(GOstats)
library(AnnotationDbi)
install.packages("vctrs", repos = "https://packagemanager.rstudio.com/cran/latest")
xcode-select --install
xcode-select --install
xcode-select --install
BiocManager::install("DESeq2")
xcode-select --install
xcode-select --reset
xcode-select --reset
#Set the correct working directory
setwd("OneDrive\ -\ University\ of\ Kansas/PierisProteomeProject/Analysis_Results/FunctionalPredictions/BLASTOutputs/")
