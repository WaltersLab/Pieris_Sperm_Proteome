write.table(x = completeAnnotationTable, file = "../completeAnnotationTable.txt", sep = "\t",
row.names = FALSE, quote = TRUE)
#Set the correct working directory
setwd("OneDrive\ -\ University\ of\ Kansas/PierisProteomeProject/Analysis_Results/FunctionalPredictions/BLASTOutputs/")
library(Biostrings)
#Part 1 - PANNZER Output
## Section A - Read in PANNZER file
pannzer <- read.delim(file = "../PANNZEROutputs/anno.out", as.is = TRUE, na.strings = "n.d.")
## Section B - Parse PANNZER annotations output
### Take long format and change to wide format in order to merge
### GeneID/queryID —> multiple "types" (set number)
### For each number of "type" - one+ observations
# unique(pannzer[2, ])  #Call unique on col 2 to find unique values for types
### Only need “DE” type with corresponding "PPV value" and "description" (should be a dataframe)
DEtype <- pannzer[pannzer$type == "DE", ]
#Rename column names before merging with pannzer
colnamesBlast <- c("query_seq.id", "subject_seq.id", "percent_identicalMatches", "alignment_length", "number_mismatches", "number_gapOpenings", "start_query.alignment", "end_query.alignment", "start_subject.alignment", "end_subject.alignment", "expect_value", "bit_value", "organism_commonName", "organism_scientificName", "organism_group", "function")
blast <- read.table(file = "../BLASTOutputs/longestCDSOutput.txt", sep = "\t", fill = TRUE, col.names = colnamesBlast)
## Section B - Merge resuts
functionalResults <- merge(x = DEtype, y = blast, by.x = c("qpid"), by.y = c("query_seq.id"))
## Section C - Merge with complete list of nonredundant transcripts
nonRedundantFAS <- readAAStringSet(filepath = "../../DataCleaning/ResultsOutput/CleanedProteomeFASTAs/PierisNonRedundant.fas")
##Generating the Table for NonRedundants
geneinfo <- read.table(file = "../../../RawData/geneID.txt", sep =";", header = FALSE, quote = "", as.is = T) #15047 gene IDs
#Update column names in the table
names(geneinfo)[1] <- "GeneID"
names(geneinfo)[2] <- "GeneName"
protNames_NR <- names(nonRedundantFAS) #class(protNames_NR)
#Remove "ID=" and "Name="
geneinfo$GeneID <- gsub("ID=", "", geneinfo$GeneID)
geneinfo$GeneName <- gsub("Name=", "", geneinfo$GeneName)
#Use the `match()` function to subset geneinfo$GeneID in a way that is consistent with the ordering and identity of transcript IDs on AAstringset read from fasta.
trxList <- strsplit(names(nonRedundantFAS), split = " gene")  #Parse fasta header from AAStringSet into list of unique IDs
prot.mtx <- do.call(what = rbind, args = trxList) #Turn this list into a matrix, to access only trxID or GeneName directly
colnamesProt.mtx <- c("TranscriptID", "GeneID", "GeneName")
colnames(prot.mtx) <- colnamesProt.mtx # prot.mtx[, 3]
prot.mtx[ , 2] <- gsub("ID=", "", prot.mtx[ , 2]) # class(prot.mtx[ , 2])
prot.mtx[ , 3] <- gsub("name=", "", prot.mtx[ , 3])
prot.geneID <- geneinfo$GeneID[match(prot.mtx[ , 3], table = geneinfo$GeneName)] #Use match to get GeneID values corresponding to GeneNames in the fasta ordering
#Combine into one table
trxID.geneName.geneID <- cbind(prot.mtx, prot.geneID)
#Fix names in table
trxID.geneName.geneID <- trxID.geneName.geneID[order(trxID.geneName.geneID[,1]), ]
write.csv(x = trxID.geneName.geneID, file = "../../DataCleaning/ResultsOutput/nonRedundant_TrxID.GeneName.GeneID.csv", row.names = F, quote = T)
nonRedundant_TrxID.GeneName.GeneID_csv <- read.csv(file = "../../DataCleaning/ResultsOutput/nonRedundant_TrxID.GeneName.GeneID.csv")
completeAnnotationTable <- merge(x = functionalResults, y = nonRedundant_TrxID.GeneName.GeneID_csv, by.x = c("qpid"), by.y = c("TranscriptID"), all.x = TRUE)
write.table(x = completeAnnotationTable, file = "../completeAnnotationTable.txt", sep = "\t",
row.names = FALSE, quote = TRUE)
head(completeAnnotationTable[500,])
# write.csv(x = completeAnnotationTable, file = "../completeAnnotationTable.csv", row.names = F, quote = T)
write.table(x = completeAnnotationTable, file = "../completeAnnotationTable.txt", sep = "\t",
row.names = FALSE, quote = TRUE)
head(completeAnnotationTable[499,])
#Set the correct working directory
setwd("OneDrive\ -\ University\ of\ Kansas/PierisProteomeProject/Analysis_Results/FunctionalPredictions/BLASTOutputs/")
library(Biostrings)
#Part 1 - PANNZER Output
## Section A - Read in PANNZER file
pannzer <- read.delim(file = "../PANNZEROutputs/anno.out", as.is = TRUE, na.strings = "n.d.", quote = "")
## Section B - Parse PANNZER annotations output
### Take long format and change to wide format in order to merge
### GeneID/queryID —> multiple "types" (set number)
### For each number of "type" - one+ observations
# unique(pannzer[2, ])  #Call unique on col 2 to find unique values for types
### Only need “DE” type with corresponding "PPV value" and "description" (should be a dataframe)
DEtype <- pannzer[pannzer$type == "DE", ]
#Rename column names before merging with pannzer
colnamesBlast <- c("query_seq.id", "subject_seq.id", "percent_identicalMatches", "alignment_length", "number_mismatches", "number_gapOpenings", "start_query.alignment", "end_query.alignment", "start_subject.alignment", "end_subject.alignment", "expect_value", "bit_value", "organism_commonName", "organism_scientificName", "organism_group", "function")
blast <- read.table(file = "../BLASTOutputs/longestCDSOutput.txt", sep = "\t", fill = TRUE, col.names = colnamesBlast, as.is = T, quote = "")
dim(blast)
## Section B - Merge resuts
functionalResults <- merge(x = DEtype, y = blast, by.x = c("qpid"), by.y = c("query_seq.id"))
dim(functionalResults)
## Section B - Merge resuts
functionalResults <- merge(x = DEtype, y = blast, by.x = c("qpid"), by.y = c("query_seq.id"), all = TRUE)
dim(functionalResults)
## Section C - Merge with complete list of nonredundant transcripts
nonRedundantFAS <- readAAStringSet(filepath = "../../DataCleaning/ResultsOutput/CleanedProteomeFASTAs/PierisNonRedundant.fas")
##Generating the Table for NonRedundants
protNames_NR <- names(nonRedundantFAS) #class(protNames_NR)
#Use the `match()` function to subset geneinfo$GeneID in a way that is consistent with the ordering and identity of transcript IDs on AAstringset read from fasta.
trxList <- strsplit(names(nonRedundantFAS), split = " gene")  #Parse fasta header from AAStringSet into list of unique IDs
prot.mtx <- do.call(what = rbind, args = trxList) #Turn this list into a matrix, to access only trxID or GeneName directly
colnamesProt.mtx <- c("TranscriptID", "GeneID", "GeneName")
colnames(prot.mtx) <- colnamesProt.mtx # prot.mtx[, 3]
prot.mtx[ , 2] <- gsub("ID=", "", prot.mtx[ , 2]) # class(prot.mtx[ , 2])
prot.mtx[ , 3] <- gsub("name=", "", prot.mtx[ , 3])
## Section C - Merge with complete list of nonredundant transcripts
lomgestCDS_FAS <- readAAStringSet(filepath = "../../DataCleaning/ResultsOutput/CleanedProteomeFASTAs/PierisLongestCDS.fas")
## Section C - Merge with complete list of nonredundant transcripts
longestCDS_FAS <- readAAStringSet(filepath = "../../DataCleaning/ResultsOutput/CleanedProteomeFASTAs/PierisLongestCDS.fas")
##Generating the Table for longestCDS
protNames_NR <- names(longestCDS_FAS) #class(protNames_NR)
#Use the `match()` function to subset geneinfo$GeneID in a way that is consistent with the ordering and identity of transcript IDs on AAstringset read from fasta.
trxList <- strsplit(names(longestCDS_FAS), split = " gene")  #Parse fasta header from AAStringSet into list of unique IDs
prot.mtx <- do.call(what = rbind, args = trxList) #Turn this list into a matrix, to access only trxID or GeneName directly
colnamesProt.mtx <- c("TranscriptID", "GeneID", "GeneName")
colnames(prot.mtx) <- colnamesProt.mtx # prot.mtx[, 3]
prot.mtx[ , 2] <- gsub("ID=", "", prot.mtx[ , 2]) # class(prot.mtx[ , 2])
prot.mtx[ , 3] <- gsub("name=", "", prot.mtx[ , 3])
## Section C - Merge with complete list of nonredundant transcripts
longestCDS_FAS <- readAAStringSet(filepath = "../../DataCleaning/ResultsOutput/CleanedProteomeFASTAs/PierisLongestCDS.fas")
##Generating the Table for longestCDS
trxList <- strsplit(names(longestCDS_FAS), split = " gene")  #Parse fasta header from AAStringSet into list of unique IDs
prot.mtx <- do.call(what = rbind, args = trxList) #Turn this list into a matrix, to access only trxID or GeneName directly
colnamesProt.mtx <- c("TranscriptID", "GeneID", "GeneName")
colnames(prot.mtx) <- colnamesProt.mtx # prot.mtx[, 3]
prot.mtx[ , 2] <- gsub("ID=", "", prot.mtx[ , 2]) # class(prot.mtx[ , 2])
prot.mtx[ , 3] <- gsub("name=", "", prot.mtx[ , 3])
write.csv(x = trxID.geneName.geneID, file = "../../DataCleaning/ResultsOutput/longestCDS_TrxID.GeneName.GeneID.csv", row.names = F, quote = T)
write.csv(x = trxID.geneName.geneID, file = "../../DataCleaning/ResultsOutput/longestCDS_TrxID.GeneName.GeneID.csv", row.names = F, quote = T)
prot.mtx <- do.call(what = rbind, args = trxList) #Turn this list into a matrix, to access only trxID or GeneName directly
colnamesProt.mtx <- c("TranscriptID", "GeneID", "GeneName")
colnames(prot.mtx) <- colnamesProt.mtx # prot.mtx[, 3]
prot.mtx[ , 2] <- gsub("ID=", "", prot.mtx[ , 2]) # class(prot.mtx[ , 2])
prot.mtx[ , 3] <- gsub("name=", "", prot.mtx[ , 3])
write.csv(x = trxID.geneName.geneID, file = "../../DataCleaning/ResultsOutput/longestCDS_TrxID.GeneName.GeneID.csv", row.names = F, quote = T)
## Section C - Merge with complete list of nonredundant transcripts
longestCDS_FAS <- readAAStringSet(filepath = "../../DataCleaning/ResultsOutput/CleanedProteomeFASTAs/PierisLongestCDS.fas")
##Generating the Table for NonRedundants
protNames_NR <- names(longestCDS_FAS) #class(protNames_NR)
#Use the `match()` function to subset geneinfo$GeneID in a way that is consistent with the ordering and identity of transcript IDs on AAstringset read from fasta.
trxList <- strsplit(names(longestCDS_FAS), split = " gene")  #Parse fasta header from AAStringSet into list of unique IDs
prot.mtx <- do.call(what = rbind, args = trxList) #Turn this list into a matrix, to access only trxID or GeneName directly
colnamesProt.mtx <- c("TranscriptID", "GeneID", "GeneName")
colnames(prot.mtx) <- colnamesProt.mtx # prot.mtx[, 3]
prot.mtx[ , 2] <- gsub("ID=", "", prot.mtx[ , 2]) # class(prot.mtx[ , 2])
prot.mtx[ , 3] <- gsub("name=", "", prot.mtx[ , 3])
prot.mtx
trxID.geneName.geneID <- do.call(what = rbind, args = trxList) #Turn this list into a matrix, to access only trxID or GeneName directly
colnamesProt.mtx <- c("TranscriptID", "GeneID", "GeneName")
colnames(trxID.geneName.geneID) <- colnamesProt.mtx # prot.mtx[, 3]
trxID.geneName.geneID[ , 2] <- gsub("ID=", "", trxID.geneName.geneID[ , 2]) # class(prot.mtx[ , 2])
trxID.geneName.geneID[ , 3] <- gsub("name=", "", trxID.geneName.geneID[ , 3])
#Fix names in table
trxID.geneName.geneID <- trxID.geneName.geneID[order(trxID.geneName.geneID[,1]), ]
trxID.geneName.geneID
write.csv(x = trxID.geneName.geneID, file = "../../DataCleaning/ResultsOutput/longestCDS_TrxID.GeneName.GeneID.csv", row.names = F, quote = T)
longestCDS_TrxID.GeneName.GeneID_csv <- read.csv(file = "../../DataCleaning/ResultsOutput/longestCDS_TrxID.GeneName.GeneID.csv")
completeAnnotationTable <- merge(x = functionalResults, y = longestCDS_TrxID.GeneName.GeneID_csv, by.x = c("qpid"), by.y = c("TranscriptID"), all.x = TRUE)
# write.csv(x = completeAnnotationTable, file = "../completeAnnotationTable.csv", row.names = F, quote = T)
write.table(x = completeAnnotationTable, file = "../completeAnnotationTable.txt", sep = "\t",
row.names = FALSE, quote = TRUE)
head(completeAnnotationTable[500,])
completeAnnotationTable
#Read in files
deSet <- read.csv(file = "/Users/katiemclaughlin/OneDrive - University of Kansas/PierisProteomeProject/Analysis_Results/DifferentialExpressionAnalysis/ResultsOutput/DE.ComprehensiveProteins.csv", header = TRUE)
BLAST.PANNZERSet <- read.csv("/Users/katiemclaughlin/OneDrive - University of Kansas/PierisProteomeProject/Analysis_Results/FunctionalPredictions/ResultsOutput/completeAnnotationTable.txt", sep = "\t")
#Merge Results
merge_by_gene <- merge(x = deSet[ , -(1:2)], y = BLAST.PANNZERSet, by = "GeneID")
#Save R Object
save(merge_by_gene, file = "/Users/katiemclaughlin/OneDrive - University of Kansas/PierisProteomeProject/Analysis_Results/PANNZER.BLAST.DE_Merged.RData")
#Write out to csv
PANNZER.BLAST.DE_Merged_Table <- write.csv(merge_by_gene,"/Users/katiemclaughlin/OneDrive - University of Kansas/PierisProteomeProject/Analysis_Results/PANNZER.BLAST.DE_Merged.csv", row.names = TRUE)
#Summarize how many proteins do or do not have annotations
apply(merge_by_gene, MAR = 2, function(x) {sum(is.na(x))})
#How many have BLAST versus how many have PANNZER
PANNZER_annotations <- !is.na(merge_by_gene$desc)
BLAST_annotations <- !is.na(merge_by_gene$function.)
annotationComparisons <- table(PANNZER_annotations, BLAST_annotations) #Cross tabulate
#Write out
write.table(annotationComparisons, file = "/Users/katiemclaughlin/OneDrive - University of Kansas/PierisProteomeProject/Analysis_Results/annotationComparisons")
#Order
all.ordered <- merge_by_gene[order(merge_by_gene$Means.All), ]
head(all.ordered)
apy.ordered <- merge_by_gene[order(merge_by_gene$Means.Apy), ]
eupy.ordered <- merge_by_gene[order(merge_by_gene$Means.Eupy), ]
library(kableExtra)
merge_by_gene[order(merge_by_gene$Means.All), ] %>% kbl() %>%  kable_paper("hover", full_width = F) %>% scroll_box(width = "800px", height = "500px")
GeneAnnotations <- merge_by_gene[ , c("GeneID", "TrxID", "Means.All", "Means.Apy", "Means.Eupy",  "Apyrene_vs_Eupyrene_p.bh", "significant_bh","Apyrene_vs_Eupyrene_diff", "desc", "subject_seq.id", "expect_value", "organism_commonName", "organism_scientificName", "organism_group", "function.")]
#Write out to csv
write.csv(GeneAnnotations, file = "/Users/katiemclaughlin/OneDrive - University of Kansas/PierisProteomeProject/Analysis_Results/GeneAnnotations.csv")
#Ordered Tables
All.ordered <- GeneAnnotations[order(GeneAnnotations$Means.All), ]
Apy.ordered <- GeneAnnotations[order(GeneAnnotations$Means.Apy), ]
Eupy.ordered <- GeneAnnotations[order(GeneAnnotations$Means.Eupy), ]
View(GeneAnnotations)
gsc.prapae
#Shared set (not BH significant) and BP gene ontology enrichment - new script
library(GOstats)
library(Category)
#Read in Sperm Protein Data
path.in <- "/Users/katiemclaughlin/OneDrive - University of Kansas/PierisProteomeProject/Analysis_Results"
#DE output from DEP
pieris.DE <- read.csv(paste0(path.in, "/DifferentialExpressionAnalysis/ResultsOutput/DE.ComprehensiveProteins.csv"), header = TRUE)
UnbiasedProteins <- pieris.DE[pieris.DE$master.de == "unbiased", ]
Eu.DE <- pieris.DE[pieris.DE$master.de == "eupyrene", ]
A.DE <- pieris.DE[pieris.DE$master.de == "apyrene", ]
UnbiasedProteins <- pieris.DE[pieris.DE$significant_bh == FALSE, ]
sharedproteins <- UnbiasedProteins$GeneID
allspermprots <- pieris.DE$GeneID
#Read in PANNZER GO Data
prapaeGO <- read.delim(paste0(path.in, "/FunctionalPredictions/PANNZEROutputs/GO.out"), as.is = TRUE)
GeneIdentifiers <- read.csv(paste0(path.in, "/DataCleaning/ResultsOutput/TrxID.GeneName.GeneID.csv"))
prapaeGO.all <- merge(x = prapaeGO, y = GeneIdentifiers[ , c(1,3)], by.x = "qpid", by.y = "TrxID") #Need geneID for transcript in GO.out
goframeData.prapae <- data.frame("go_id" = sprintf("GO:%07d", prapaeGO.all$goid), "Evidence" = "ISS", "gene_id" = prapaeGO.all$GeneID)
allprots.prapae <- unique(prapaeGO.all$qpid) #Prapae sperm proteins with GO annotations
goframeData.prapae
allprots.prapae
GeneIdentifiers
prapaeGO
pieris.DE
is.na(pieris.DE$master.de)
pieris.DE$master.de == "apyrene"
pieris.DE[pieris.DE$master.de == "apyrene"]
pieris.DE[, pieris.DE$master.de == "apyrene"]
pieris.DE[pieris.DE$master.de == "apyrene", ]
apyreneBiased <- pieris.DE[pieris.DE$master.de == "apyrene", ]
apyreneBiased
load("/Users/katiemclaughlin/Library/CloudStorage/OneDrive-UniversityofKansas/PierisProteomeProject/Analysis_Results/FunctionalPredictions/ResultsOutput/HG.list.RData")
View(HG.list)
GeneAnnotations
GeneAnnotations$function.
GeneAnnotations
apyreneBiased$
GeneAnnotations$GeneID
apyreneBiased$
GeneAnnotations$GeneID
apyreneBiased$GeneID
GeneAnnotations$GeneID
GeneAnnotations$GeneID[apyreneBiased$GeneID]
GeneAnnotations$GeneID[apyreneBiased$GeneID, ]
GeneAnnotations$GeneID[ , apyreneBiased$GeneID]
GeneAnnotations$GeneID = apyreneBiased$GeneID
geneIDs <- GeneAnnotations$GeneID = apyreneBiased$GeneID
geneIDs <- GeneAnnotations$GeneID = apyreneBiased$GeneID
geneIDs <- GeneAnnotations$GeneID %in% apyreneBiased$GeneID
geneIDs
GeneAnnotations$desc[geneIDs]
is.na(GeneAnnotations$desc[geneIDs])
apyreneBiased <- pieris.DE[pieris.DE$master.de == "apyrene", ]
apygeneIDs <- GeneAnnotations$GeneID %in% apyreneBiased$GeneID
GeneAnnotations$desc[apygeneIDs]
is.na(GeneAnnotations$desc[apygeneIDs])
eupyreneBiased <- pieris.DE[pieris.DE$master.de == "eupyrene", ]
eupygeneIDs <- GeneAnnotations$GeneID %in% eupyreneBiased$GeneID
GeneAnnotations$desc[eupygeneIDs]
is.na(GeneAnnotations$desc[eupygeneIDs])
sum(is.na(GeneAnnotations$desc[eupygeneIDs]))
sum(is.na(GeneAnnotations$desc[apygeneIDs]))
abline(lm(lengthSSUnique ~ geneLength), col = "blue")
knitr::opts_chunk$set(fig.align = 'center', out.width = '80%', echo = TRUE)
library(Biostrings)
tinytex::install_tinytex()
pierisGenome <- readAAStringSet(file = "../../RawData/Pieris_rapae_proteins.fa")
pierisGenome
##Generating the Table
geneinfo <- read.table(file = "../../RawData/geneID.txt", sep =";", header = FALSE, quote = "", as.is = T) #15047 gene IDs
#Update column names in the table
names(geneinfo)[1] <- "GeneID"
names(geneinfo)[2] <- "GeneName"
protNames <- names(pierisGenome)
#Remove "ID=" and "Name="
geneinfo$GeneID <- gsub("ID=", "", geneinfo$GeneID)
geneinfo$GeneName <- gsub("Name=", "", geneinfo$GeneName)
#Use the `match()` function to subset geneinfo$GeneID in a way that is consistent with the ordering and identity of transcript IDs on AAstringset read from fasta.
trxList <- strsplit(names(pierisGenome), split = " gene=")  #Parse fasta header from AAStringSet into list of unique IDs
prot.mtx <- do.call(what = rbind, args = trxList) #Turn this list into a matrix, to access only trxID or GeneName directly
names(prot.mtx)[1] <- "TranscriptID"
names(prot.mtx)[2] <- "GeneName"
prot.geneID <- geneinfo$GeneID[match(prot.mtx[,2], table = geneinfo$GeneName )] #Use match to get GeneID values corresponding to GeneNames in the fasta ordering
#Combine into one table
trxID.geneName.geneID <- cbind(prot.mtx, prot.geneID)
#Fix names in table
colnames(trxID.geneName.geneID) <- c("TrxID", "GeneName", "GeneID")
## write.csv(x = trxID.geneName.geneID[order(trxID.geneName.geneID[,1]), ], file = "../ResultsOutput/TrxID.GeneName.GeneID.csv", row.names = F, quote = T)
geneID <- strsplit(names(pierisGenome), split = " gene=")
prot.mtx <- do.call(what = rbind, args = geneID)
geneAAsetsList <- split(pierisGenome, f = prot.mtx[,2])
lengthSS <- sapply(geneAAsetsList, length)
geneAAsetsListuniq <- lapply(geneAAsetsList, unique)
lengthSSUnique <- sapply(geneAAsetsListuniq, length) #Length = count of transcripts
diff_counts <- lengthSS - lengthSSUnique #difference in counts of original vs unique proteins
plot(x = lengthSSUnique, y = diff_counts, pch = 19, xlab = "Unique Proteins",
ylab = "Difference in Counts of Original versus Unique Proteins", col = rgb(0,0,0,0.1))
lmFit <- lm(diff_counts ~ lengthSSUnique)
tmp <- summary.aov(lmFit)
abline(lmFit, col = "blue")
diffLengths <- lengthSS - lengthSSUnique
diffLengthsTable <- table(diffLengths) #Tabulate the counts
diffLengthsTable = diffLengthsTable[-c(1)]
barplot(diffLengthsTable, xlab = "Count Length", ylab = "Frequency",
main = "Difference Between Original and Unique Transcript Length", ylim = c(0,2000), space = 0)
abline(lm(lengthSSUnique ~ geneLength), col = "blue")
plot(x = geneLength, y = lengthSSUnique, pch = 19, xlab = "Gene Length",
ylab = "Unique Transcripts", col = rgb(0,0,0,0.1))
plot(x = geneLength, y = lengthSSUnique, pch = 19, xlab = "Gene Length",
ylab = "Unique Transcripts", col = rgb(0,0,0,0.1))
lmFit2 <- lm(lengthSSUnique ~ geneLength)
tmp2 <- summary.aov(lmFit2)
abline(lmFit2, col = "blue")
abline(lm(lengthSSUnique ~ geneLength), col = "blue")
geneLength <- sapply(longestSeqList, FUN = width)
longestSeqList <- sapply(geneAAsetsList, FUN = getLongest)
getLongest <- function(x) {
indexSeq <- which.max(width(x))
longestSSObject <- x[indexSeq]
return(longestSSObject)
}
longestSeqList <- sapply(geneAAsetsList, FUN = getLongest)
geneLength <- sapply(longestSeqList, FUN = width)
plot(x = geneLength, y = lengthSSUnique, pch = 19, xlab = "Gene Length",
ylab = "Unique Transcripts", col = rgb(0,0,0,0.1))
tmp2 <- summary.aov(lmFit2)
abline(lmFit2, col = "blue")
abline(lm(lengthSSUnique ~ geneLength), col = "blue")
plot(x = geneLength, y = lengthSSUnique, pch = 19, xlab = "Gene Length",
ylab = "Unique Transcripts", col = rgb(0,0,0,0.1))
lmFit2 <- lm(lengthSSUnique ~ geneLength)
tmp2 <- summary.aov(lmFit2)
abline(lmFit2, col = "blue")
abline(lm(lengthSSUnique ~ geneLength), col = "blue")
plot(x = lengthSSUnique, y = diff_counts, pch = 19, xlab = "Unique Proteins",
ylab = "Difference in Counts of Original versus Unique Proteins", col = rgb(0,0,0,0.1))
lmFit <- lm(diff_counts ~ lengthSSUnique)
tmp <- summary.aov(lmFit)
abline(lmFit, col = "blue")
plot(x = lengthSSUnique, y = diff_counts, pch = 19, xlab = "Unique Proteins",
ylab = "Difference in Counts of Original versus Unique Proteins", col = rgb(0,0,0,0.1))
lmFit <- lm(diff_counts ~ lengthSSUnique)
tmp <- summary.aov(lmFit)
abline(lmFit, col = "blue")
tmp2
tmp
pieris.DE
GeneAnnotations
pieris.DE
annotationComparisons
#Write out
write.table(annotationComparisons, file = "/Users/katiemclaughlin/OneDrive - University of Kansas/PierisProteomeProject/Analysis_Results/annotationComparisons.txt")
PANNZER.BLAST.DE_Merged_Table
#Read in files
deSet <- read.csv(file = "/Users/katiemclaughlin/OneDrive - University of Kansas/PierisProteomeProject/Analysis_Results/DifferentialExpressionAnalysis/ResultsOutput/DE.ComprehensiveProteins.csv", header = TRUE)
BLAST.PANNZERSet <- read.csv("/Users/katiemclaughlin/OneDrive - University of Kansas/PierisProteomeProject/Analysis_Results/FunctionalPredictions/ResultsOutput/completeAnnotationTable.txt", sep = "\t")
#Merge Results
merge_by_gene <- merge(x = deSet[ , -(1:2)], y = BLAST.PANNZERSet, by = "GeneID")
#Save R Object
save(merge_by_gene, file = "/Users/katiemclaughlin/OneDrive - University of Kansas/PierisProteomeProject/Analysis_Results/PANNZER.BLAST.DE_Merged.RData")
#Write out to csv
PANNZER.BLAST.DE_Merged_Table <- write.csv(merge_by_gene,"/Users/katiemclaughlin/OneDrive - University of Kansas/PierisProteomeProject/Analysis_Results/PANNZER.BLAST.DE_Merged.csv", row.names = TRUE)
PANNZER.BLAST.DE_Merged_Table
#Cross-Tabulate
merge_by_gene$master
#Cross-Tabulate
merge_by_gene$master.de
is.na(merge_by_gene$desc)
#Cross-Tabulate
desc <- merge_by_gene$master.de
type <- is.na(merge_by_gene$desc)
table(desc, type)
missingannotations <- table(desc, type)
chisq.test(missingannotations)
#Write out to table
write.table(missingannotations, file = "/Users/katiemclaughlin/OneDrive - University of Kansas/PierisProteomeProject/Analysis_Results/missingannotations.txt")
